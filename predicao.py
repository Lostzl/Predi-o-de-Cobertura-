# -*- coding: utf-8 -*-
"""competicao_I

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BGAhd04_wTZZGJ6vT_6vstqKKib1Y2_6
"""

from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.naive_bayes import GaussianNB, MultinomialNB, BernoulliNB
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score, ConfusionMatrixDisplay
from sklearn.preprocessing import StandardScaler, LabelEncoder
import pandas as pd
import csv
import matplotlib.pyplot as plt


dt_train = pd.read_csv('train.csv', low_memory=False)
dt_test = pd.read_csv('test.csv', low_memory=False)


# * Por ser uma feature importante DS_TIPO_ATENDIMENTO, os valores NaN foram 
#   substituidos por atendimentos do tipo EXAMES, que são os mais comuns. 
# * Da mesma forma DS_INDICACAO_ACIDENTE, foi preenchido com Não Acidente os valores 
#   NaN, por serem mais comuns os tipos de atendimento "Não Acidente".
# * CD_CID foi atualizado os valores NaN para Z00(exame geral), por ser uma coluna 
#   importante para análise (diz qual a doença do paciente).
# * DT_NASCIMENTO foi atualizado os valores NaN para 0.0, por ser uma coluna 
#   importante para análise, pois apresenta a idade do paciente.
def process (dt):
  dt.DS_TIPO_ATENDIMENTO = dt.DS_TIPO_ATENDIMENTO.fillna('Exames', inplace=False)
  dt.DS_INDICACAO_ACIDENTE = dt.DS_INDICACAO_ACIDENTE.fillna('N?o acidente', inplace=False)
  dt.NR_PRODUTO = dt.NR_PRODUTO.fillna(1.0, inplace=False)
  dt.CD_CID = dt.CD_CID.fillna('Z00', inplace=False)


# Transformando Variáveis Categóricas em Discretas. 
def categ_disc(dt):
  le = LabelEncoder()
  dt['DS_SUBGRUPO'] = le.fit_transform(dt['DS_SUBGRUPO'])
  dt['DS_CBO'] = le.fit_transform(dt['DS_CBO'])
  dt['CD_CID'] = le.fit_transform(dt['CD_CID'])

  
process(dt_train)
process(dt_test)
categ_disc(dt_train)
categ_disc(dt_test)


# Removendo colunas com Valores Nulos
dt_train = dt_train.dropna(axis=1)
dt_test = dt_test.dropna(axis=1)


# Separando CLASSE dos dados de TREINO e o ID dos dados de TESTE.
dt_trainy = pd.DataFrame(dt_train[["DS_STATUS_ITEM"]])
dt_id = pd.DataFrame(dt_test[["Unnamed: 0"]])


# Removendo colunas que não serão utilizadas.
dt_train = pd.DataFrame(dt_train.drop(["Unnamed: 0", "DS_ITEM", "DS_STATUS_ITEM", "DS_CLASSE"], axis=1))
dt_test = pd.DataFrame(dt_test.drop(["Unnamed: 0", "DS_ITEM", "DS_CLASSE", "DT_NASCIMENTO"], axis=1))


# Transformando Variáveis Categóricas em Discretas.
for cat_var in dt_train.select_dtypes(include='O').columns:
    le = LabelEncoder()
    le.fit(dt_train[cat_var])
    dt_train[cat_var + '_num'] = le.transform(dt_train[cat_var])
    dt_train.drop(cat_var, axis=1, inplace=True)
    dt_test[cat_var + '_num'] = le.transform(dt_test[cat_var])
    dt_test.drop(cat_var, axis=1, inplace=True)


# Separação dos dados para TESTE de algoritmos.
x_train, x_test, y_train, y_test = train_test_split(dt_train, dt_trainy, train_size=0.8, random_state=3)


# Separação dos dados quando para PREDIÇÃO REAL.
x_train = dt_train
y_train = dt_trainy
x_test = dt_test


# Algoritimo NAIVE_BAYES.
clf = GaussianNB()


# Algoritimo RANDOM FOREST.
clf = RandomForestClassifier(n_estimators=30, max_depth=None, min_samples_split=2, random_state=3)


# Treinamento
clf.fit(x_train, y_train.values.ravel())


# Verificação de Métricas para medir o desempenho da Classificação.
y_true, y_pred = y_test, clf.predict(x_test)
c = confusion_matrix(y_test, y_pred)
print(classification_report(y_true, y_pred))
print('\nAccuracy: {:.3f}%'.format(float(accuracy_score(y_test, y_pred) * 100)))
print('\nConfusion Matrix:')
disp = ConfusionMatrixDisplay(confusion_matrix=c,
                              display_labels=clf.classes_)
disp.plot()


# Predição dos dados de Teste.
j = clf.predict(x_test)


# Geração do arquivo CSV do resultado.
submission = pd.read_csv('submission_test.csv')
submission['ID'] = pd.DataFrame(dt_id['Unnamed: 0'])
submission['DS_STATUS_ITEM'] = j
submission.to_csv('submission_nb_ult.csv', index=False)
